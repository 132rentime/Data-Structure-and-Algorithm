## 排序算法

#### 测试用例

- 随机数组
- 近乎有序的数组
- 重复值很多的数组



#### 学习`O(n^2)`排序算法

- 基础
- 代码简单，易于实现
- 某些特殊情况下，简单的排序算法更有效
- 作为子过程，改进更复杂的排序算法



#### 选择排序

从头到尾扫描数组，找出最小的元素，和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序数组

特点：**两层循环必须完全执行完成**



#### 插入排序

将数组的第一个元素认为是有序数组，从后往前扫描有序数组，把数组中剩下的元素根据大小插入到有序数组中，直到数组有序为止

特点：**循环可以提前结束**

优化：**swap操作耗时**，需要把swap操作改为比较和赋值操作

**插入排序针对于近乎有序的数组，时间复杂度近乎`O(n)`**



#### 希尔排序

#### 冒泡排序



#### 归并排序

- 递归实现（自顶向下）

- 迭代实现（自底向上），可以对链表进行排序


优化1：**提前判断待合并的两个子数组是否已经有序**

优化2： 元素量很小的时候， 子数组采用插入排序

元素量很小的时候，子数组有序的概率很大

元素量很小的时候，`O(n^2)`和`O(nlogn)`的时间复杂度主要表现在系数方面

应用：归并排序求逆序对



#### 快速排序

优化1： 元素量很小的时候， 子数组采用插入排序

优化2：针对近乎有序的数组，随机选择锚点

优化3：针对重复值很多的数组，**双路快排**或者**三路快排**

应用：快速排序获取数组第K大的元素



#### 堆排序

先将排序元素构建为一个最大堆（heapify），每次从堆中取出最大元素并调整堆，将取出的最大元素放到已排好序的序列前面

堆排序性能不如快速排序

- **堆排序访问数据的方式没有快速排序友好，不利于CPU缓存**
- 堆化的过程导致数据有序度降低，导致交换次数增加



|          | 平均时间复杂度 | 额外空间  | 原地排序 | 稳定排序 |
| :------: | :------------: | :-------: | :------: | :------: |
| 插入排序 |    `O(n^2)`    |  `O(1)`   |    √     |    √     |
| 归并排序 |   `O(nlogn)`   |  `O(n)`   |    ×     |    √     |
| 快速排序 |   `O(nlogn)`   | `O(logn)` |    √     |    ×     |
|  堆排序  |   `O(nlogn)`   |  `O(1)`   |    √     |    ×     |



#### 桶排序

#### 计数排序

#### 基数排序



#### 参考

1. [算法与数据结构--综合提升篇（c++版）](https://coding.imooc.com/class/71.html)